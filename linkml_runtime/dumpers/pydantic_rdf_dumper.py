"""
RDF dumper for Pydantic models that uses embedded LinkML metadata.

This dumper works directly with Pydantic models generated by LinkML,
using only the embedded linkml_meta without requiring a SchemaView.
"""

import logging
import urllib.parse
from dataclasses import dataclass
from typing import Any, Dict, List, Optional, Union

from pydantic import BaseModel
from rdflib import XSD, Graph, URIRef, Namespace
from rdflib.namespace import RDF, RDFS
from rdflib.term import BNode, Literal, Node

from linkml_runtime.dumpers.dumper_root import Dumper
from linkml_runtime.linkml_model import PermissibleValue, PermissibleValueText

logger = logging.getLogger(__name__)


@dataclass
class PydanticRDFContext:
    """Context for Pydantic RDF conversion using embedded metadata"""
    graph: Graph
    prefixes: Dict[str, str]
    global_meta: Dict[str, Any]
    
    def get_namespace(self, prefix: str) -> Optional[Namespace]:
        """Get namespace for a prefix"""
        if prefix in self.prefixes:
            return Namespace(self.prefixes[prefix])
        return None
    
    def expand_curie(self, curie_or_uri: str) -> str:
        """Expand a CURIE to full URI"""
        if "://" in curie_or_uri:
            return curie_or_uri
        if ":" in curie_or_uri:
            prefix, local = curie_or_uri.split(":", 1)
            if prefix in self.prefixes:
                return self.prefixes[prefix] + local
        return curie_or_uri


class PydanticRDFDumper(Dumper):
    """
    Dumps Pydantic models to RDF using embedded LinkML metadata.
    
    This dumper extracts all necessary schema information from the
    linkml_meta attributes embedded in Pydantic models, eliminating
    the need for a separate SchemaView.
    """
    
    def as_rdf_graph(
        self,
        element: BaseModel,
        prefix_map: Optional[Dict[str, str]] = None,
    ) -> Graph:
        """
        Convert Pydantic model to RDF Graph using embedded metadata
        
        :param element: Pydantic model instance to convert
        :param prefix_map: Optional additional prefix mappings
        :return: RDF Graph
        """
        # Initialize empty RDF graph
        g = Graph()
        
        # Extract global metadata from the model
        global_meta = self._extract_global_metadata(element)
        
        # Build prefix map from metadata and optional overrides
        prefixes = {}
        if "prefixes" in global_meta:
            for prefix_info in global_meta["prefixes"].values():
                prefixes[prefix_info["prefix_prefix"]] = prefix_info["prefix_reference"]
        
        # Add any user-provided prefixes
        if prefix_map:
            prefixes.update(prefix_map)
        
        # Bind namespaces to graph
        for prefix, uri in prefixes.items():
            g.namespace_manager.bind(prefix, URIRef(uri))
        
        # Create conversion context
        ctx = PydanticRDFContext(
            graph=g,
            prefixes=prefixes,
            global_meta=global_meta
        )
        
        # Convert the element
        self.inject_triples(element, ctx)
        return g
    
    def inject_triples(self, element: Any, ctx: PydanticRDFContext) -> Node:
        """
        Convert an element to RDF triples using Pydantic metadata
        
        :param element: Element to convert
        :param ctx: Conversion context
        :return: RDF Node representing the element
        """
        # Handle primitive types
        if isinstance(element, (str, int, float, bool)):
            return self._handle_primitive(element)
        
        # Handle lists
        if isinstance(element, list):
            # For now, return first element if exists (simplified handling)
            if element:
                return self.inject_triples(element[0], ctx)
            return Literal("")
        
        # Handle None
        if element is None:
            return Literal("")
        
        # Handle Pydantic models
        if isinstance(element, BaseModel):
            return self._handle_pydantic_model(element, ctx)
        
        # Handle other types as literals
        return Literal(str(element))
    
    def _handle_primitive(self, element: Any) -> Node:
        """Handle primitive types"""
        if isinstance(element, bool):
            return Literal(element, datatype=XSD.boolean)
        elif isinstance(element, int):
            return Literal(element, datatype=XSD.integer)
        elif isinstance(element, float):
            return Literal(element, datatype=XSD.decimal)
        else:
            # Handle dates and other types
            from datetime import date, datetime
            if isinstance(element, date):
                return Literal(element.isoformat(), datatype=XSD.date)
            elif isinstance(element, datetime):
                return Literal(element.isoformat(), datatype=XSD.dateTime)
            else:
                return Literal(str(element))
    
    def _handle_pydantic_model(self, element: BaseModel, ctx: PydanticRDFContext) -> Node:
        """Handle Pydantic model instances"""
        # Get class metadata
        class_meta = self._get_class_metadata(element)
        
        # Create subject URI
        subject_uri = self._create_subject_uri(element, class_meta, ctx)
        
        # Add type triple
        self._add_type_triple(subject_uri, class_meta, ctx)
        
        # Process properties
        self._process_model_properties(element, subject_uri, ctx)
        
        return subject_uri
    
    def _get_class_metadata(self, element: BaseModel) -> Dict[str, Any]:
        """Extract class metadata from Pydantic model"""
        element_type = type(element)
        if hasattr(element_type, 'linkml_meta'):
            return element_type.linkml_meta.root
        return {"name": element_type.__name__}
    
    def _create_subject_uri(self, element: BaseModel, class_meta: Dict[str, Any], ctx: PydanticRDFContext) -> Node:
        """Create subject URI for the element"""
        # Look for identifier field
        id_field = getattr(element, 'id', None)
        if id_field:
            # Expand CURIE if needed
            expanded_uri = ctx.expand_curie(str(id_field))
            return URIRef(expanded_uri)
        
        # No identifier - create blank node
        return BNode()
    
    def _add_type_triple(self, subject_uri: Node, class_meta: Dict[str, Any], ctx: PydanticRDFContext):
        """Add rdf:type triple for the element"""
        class_uri = class_meta.get("class_uri")
        if class_uri:
            # Expand CURIE to full URI
            expanded_uri = ctx.expand_curie(class_uri)
            ctx.graph.add((subject_uri, RDF.type, URIRef(expanded_uri)))
        else:
            # Fallback to class name
            class_name = class_meta.get("name", "Unknown")
            from_schema = class_meta.get("from_schema", "")
            if from_schema:
                class_uri = f"{from_schema}#{class_name}"
            else:
                class_uri = f"#{class_name}"
            ctx.graph.add((subject_uri, RDF.type, URIRef(class_uri)))
    
    def _process_model_properties(self, element: BaseModel, subject_uri: Node, ctx: PydanticRDFContext):
        """Process all properties of a Pydantic model"""
        # Get field definitions from the class, not the instance
        model_fields = type(element).model_fields
        
        # Iterate through model fields
        for field_name, field_value in element.model_dump().items():
            if field_value is None:
                continue
                
            # Get field metadata
            field_info = model_fields.get(field_name)
            if not field_info:
                continue
            
            field_meta = self._get_field_metadata(field_info)
            
            # Skip identifier fields (already used for subject URI)
            if field_name == 'id':
                continue
            
            # Create property URI
            property_uri = self._get_property_uri(field_meta, field_name, ctx)
            
            # Handle field value - get the actual field value from the model, not the dumped dict
            actual_field_value = getattr(element, field_name)
            self._add_property_triples(subject_uri, property_uri, actual_field_value, ctx)
    
    def _get_field_metadata(self, field_info) -> Dict[str, Any]:
        """Extract metadata from Pydantic field"""
        if hasattr(field_info, 'json_schema_extra') and field_info.json_schema_extra:
            linkml_meta = field_info.json_schema_extra.get('linkml_meta', {})
            return linkml_meta
        return {}
    
    def _get_property_uri(self, field_meta: Dict[str, Any], field_name: str, ctx: PydanticRDFContext) -> URIRef:
        """Get property URI from field metadata"""
        # Check for slot_uri in metadata
        slot_uri = field_meta.get("slot_uri")
        if slot_uri:
            return URIRef(ctx.expand_curie(slot_uri))
        
        # Check for exact_mappings
        exact_mappings = field_meta.get("exact_mappings", [])
        if exact_mappings:
            return URIRef(ctx.expand_curie(exact_mappings[0]))
        
        # Fallback: use from_schema + field name
        from_schema = field_meta.get("from_schema", "")
        if from_schema:
            # Ensure from_schema ends with / or #
            if not from_schema.endswith(("/", "#")):
                from_schema += "/"
            return URIRef(from_schema + field_name)
        
        # Final fallback
        return URIRef(f"#{field_name}")
    
    def _add_property_triples(self, subject_uri: Node, property_uri: URIRef, value: Any, ctx: PydanticRDFContext):
        """Add triples for a property value"""
        if isinstance(value, list):
            # Handle multivalued properties
            for item in value:
                object_node = self.inject_triples(item, ctx)
                ctx.graph.add((subject_uri, property_uri, object_node))
        else:
            # Handle single value
            object_node = self.inject_triples(value, ctx)
            ctx.graph.add((subject_uri, property_uri, object_node))
    
    def _extract_global_metadata(self, element: BaseModel) -> Dict[str, Any]:
        """Extract global metadata from the model module"""
        try:
            import importlib
            module_obj = importlib.import_module(element.__class__.__module__)
            if hasattr(module_obj, 'linkml_meta'):
                return module_obj.linkml_meta.root
        except ImportError:
            pass
        
        return {}
    
    def dump(
        self,
        element: BaseModel,
        to_file: str,
        fmt: str = "turtle",
        prefix_map: Optional[Dict[str, str]] = None,
        **args,
    ) -> None:
        """
        Write element as RDF to file
        
        :param element: Pydantic model to convert
        :param to_file: Output file path
        :param fmt: RDF format (turtle, xml, etc.)
        :param prefix_map: Optional prefix mappings
        """
        graph = self.as_rdf_graph(element, prefix_map=prefix_map)
        with open(to_file, 'w') as f:
            f.write(graph.serialize(format=fmt))
    
    def dumps(
        self,
        element: BaseModel,
        fmt: str = "turtle",
        prefix_map: Optional[Dict[str, str]] = None,
    ) -> str:
        """
        Convert element to RDF string
        
        :param element: Pydantic model to convert
        :param fmt: RDF format (turtle, xml, etc.)
        :param prefix_map: Optional prefix mappings
        :return: RDF string
        """
        graph = self.as_rdf_graph(element, prefix_map=prefix_map)
        return graph.serialize(format=fmt)